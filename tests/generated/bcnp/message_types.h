// AUTO-GENERATED by bcnp_codegen.py - DO NOT EDIT
// Schema version: 3.0
// Schema hash: 0x20ECF17D
#pragma once

#include <array>
#include <cstddef>
#include <cstdint>
#include <cmath>
#include <cstring>
#include <functional>
#include <limits>
#include <optional>
#include <variant>

namespace bcnp {

// ============================================================================
// Protocol Constants
// ============================================================================

constexpr uint8_t kProtocolMajorV3 = 3;
constexpr uint8_t kProtocolMinorV3 = 0;
constexpr uint32_t kSchemaHash = 0x20ECF17DU;

// Handshake packet structure: "BCNP" (4 bytes) + schema hash (4 bytes)
constexpr std::size_t kHandshakeSize = 8;
constexpr std::array<uint8_t, 4> kHandshakeMagic = {{'B', 'C', 'N', 'P'}};

// V3 Header: Major(1) + Minor(1) + Flags(1) + MsgTypeId(2) + MsgCount(2) = 7 bytes
constexpr std::size_t kHeaderSizeV3 = 7;
constexpr std::size_t kHeaderMsgTypeIndex = 3;
constexpr std::size_t kHeaderMsgCountIndex = 5;

// ============================================================================
// Message Type IDs
// ============================================================================

enum class MessageTypeId : uint16_t {
    Unknown = 0,
    TestCmd = 1,
};

// Message sizes (wire format, bytes)
constexpr std::size_t kTestCmdSize = 10;

// ============================================================================
// Byte Order Utilities (Big-Endian Wire Format)
// ============================================================================

namespace detail {

inline uint16_t LoadU16(const uint8_t* p) {
    return (uint16_t(p[0]) << 8) | uint16_t(p[1]);
}

inline uint32_t LoadU32(const uint8_t* p) {
    return (uint32_t(p[0]) << 24) | (uint32_t(p[1]) << 16) |
           (uint32_t(p[2]) << 8) | uint32_t(p[3]);
}

inline int16_t LoadS16(const uint8_t* p) {
    return static_cast<int16_t>(LoadU16(p));
}

inline int32_t LoadS32(const uint8_t* p) {
    return static_cast<int32_t>(LoadU32(p));
}

inline void StoreU16(uint16_t v, uint8_t* p) {
    p[0] = static_cast<uint8_t>((v >> 8) & 0xFF);
    p[1] = static_cast<uint8_t>(v & 0xFF);
}

inline void StoreU32(uint32_t v, uint8_t* p) {
    p[0] = static_cast<uint8_t>((v >> 24) & 0xFF);
    p[1] = static_cast<uint8_t>((v >> 16) & 0xFF);
    p[2] = static_cast<uint8_t>((v >> 8) & 0xFF);
    p[3] = static_cast<uint8_t>(v & 0xFF);
}

inline void StoreS16(int16_t v, uint8_t* p) {
    StoreU16(static_cast<uint16_t>(v), p);
}

inline void StoreS32(int32_t v, uint8_t* p) {
    StoreU32(static_cast<uint32_t>(v), p);
}

inline int32_t QuantizeFloat(float value, float scale) {
    const double scaled = static_cast<double>(value) * static_cast<double>(scale);
    const double clamped = std::clamp(scaled,
        static_cast<double>(std::numeric_limits<int32_t>::min()),
        static_cast<double>(std::numeric_limits<int32_t>::max()));
    return static_cast<int32_t>(std::llround(clamped));
}

inline float DequantizeFloat(int32_t fixed, float scale) {
    return static_cast<float>(static_cast<double>(fixed) / static_cast<double>(scale));
}

} // namespace detail

// ============================================================================
// Message Structs
// ============================================================================

/// Test command for unit tests
struct TestCmd {
    static constexpr MessageTypeId kTypeId = MessageTypeId::TestCmd;
    static constexpr std::size_t kWireSize = kTestCmdSize;

    float value1{0}; // First test value
    float value2{0}; // Second test value
    uint16_t durationMs{0}; // Command duration in milliseconds (ms)

    bool Encode(uint8_t* out, std::size_t capacity) const {
        if (capacity < kWireSize) return false;
        if (!std::isfinite(value1)) return false;
        detail::StoreS32(detail::QuantizeFloat(value1, 10000.0f), &out[0]);
        if (!std::isfinite(value2)) return false;
        detail::StoreS32(detail::QuantizeFloat(value2, 10000.0f), &out[4]);
        detail::StoreU16(durationMs, &out[8]);
        return true;
    }

    static std::optional<TestCmd> Decode(const uint8_t* data, std::size_t length) {
        if (length < kWireSize) return std::nullopt;
        TestCmd msg;
        msg.value1 = detail::DequantizeFloat(detail::LoadS32(&data[0]), 10000.0f);
        if (!std::isfinite(msg.value1)) return std::nullopt;
        msg.value2 = detail::DequantizeFloat(detail::LoadS32(&data[4]), 10000.0f);
        if (!std::isfinite(msg.value2)) return std::nullopt;
        msg.durationMs = detail::LoadU16(&data[8]);
        return msg;
    }
};

// ============================================================================
// Message Variant (for type-erased handling)
// ============================================================================

using Message = std::variant<TestCmd>;

// ============================================================================
// Message Registry
// ============================================================================

struct MessageInfo {
    MessageTypeId typeId;
    std::size_t wireSize;
    const char* name;
};

inline constexpr std::array<MessageInfo, 1> kMessageRegistry = {{
    {MessageTypeId::TestCmd, 10, "TestCmd"},
}};

inline std::optional<MessageInfo> GetMessageInfo(MessageTypeId typeId) {
    for (const auto& info : kMessageRegistry) {
        if (info.typeId == typeId) return info;
    }
    return std::nullopt;
}

inline std::optional<MessageInfo> GetMessageInfo(uint16_t typeId) {
    return GetMessageInfo(static_cast<MessageTypeId>(typeId));
}

// ============================================================================
// Handshake Utilities
// ============================================================================

/// Encode handshake with default schema hash
inline bool EncodeHandshake(uint8_t* out, std::size_t capacity) {
    if (capacity < kHandshakeSize) return false;
    std::memcpy(out, kHandshakeMagic.data(), 4);
    detail::StoreU32(kSchemaHash, &out[4]);
    return true;
}

/// Encode handshake with custom schema hash (for testing)
inline bool EncodeHandshakeWithHash(uint8_t* out, std::size_t capacity, uint32_t schemaHash) {
    if (capacity < kHandshakeSize) return false;
    std::memcpy(out, kHandshakeMagic.data(), 4);
    detail::StoreU32(schemaHash, &out[4]);
    return true;
}

inline bool ValidateHandshake(const uint8_t* data, std::size_t length) {
    if (length < kHandshakeSize) return false;
    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;
    const uint32_t remoteHash = detail::LoadU32(&data[4]);
    return remoteHash == kSchemaHash;
}

/// Validate handshake against custom expected hash (for testing)
inline bool ValidateHandshakeWithHash(const uint8_t* data, std::size_t length, uint32_t expectedHash) {
    if (length < kHandshakeSize) return false;
    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;
    const uint32_t remoteHash = detail::LoadU32(&data[4]);
    return remoteHash == expectedHash;
}

inline uint32_t ExtractSchemaHash(const uint8_t* data, std::size_t length) {
    if (length < kHandshakeSize) return 0;
    return detail::LoadU32(&data[4]);
}

} // namespace bcnp
