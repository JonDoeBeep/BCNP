// AUTO-GENERATED by bcnp_codegen.py - DO NOT EDIT
// Schema version: 3.2
// Schema hash: 0x2A9C6F4F
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <cmath>
#include <cstring>
#include <functional>
#include <limits>
#include <optional>
#include <variant>

namespace bcnp {

// ============================================================================
// Protocol Constants
// ============================================================================

constexpr uint8_t kProtocolMajorV3 = 3;
constexpr uint8_t kProtocolMinorV3 = 2;
constexpr uint32_t kSchemaHash = 0x2A9C6F4FU;

// Handshake packet structure: "BCNP" (4 bytes) + schema hash (4 bytes)
constexpr std::size_t kHandshakeSize = 8;
constexpr std::array<uint8_t, 4> kHandshakeMagic = {{'B', 'C', 'N', 'P'}};

// V3 Header: Major(1) + Minor(1) + Flags(1) + MsgTypeId(2) + MsgCount(2) = 7 bytes
constexpr std::size_t kHeaderSizeV3 = 7;
constexpr std::size_t kHeaderMsgTypeIndex = 3;
constexpr std::size_t kHeaderMsgCountIndex = 5;

// ============================================================================
// Message Type IDs
// ============================================================================

enum class MessageTypeId : uint16_t {
    Unknown = 0,
    TestCmd = 1,
    DrivetrainState = 10,
    EncoderData = 11,
    ProximityAlert = 12,
};

// Message sizes (wire format, bytes)
constexpr std::size_t kTestCmdSize = 10;
constexpr std::size_t kDrivetrainStateSize = 20;
constexpr std::size_t kEncoderDataSize = 9;
constexpr std::size_t kProximityAlertSize = 4;

// ============================================================================
// Byte Order Utilities (Big-Endian Wire Format)
// ============================================================================

namespace detail {

inline uint16_t LoadU16(const uint8_t* p) {
    return (uint16_t(p[0]) << 8) | uint16_t(p[1]);
}

inline uint32_t LoadU32(const uint8_t* p) {
    return (uint32_t(p[0]) << 24) | (uint32_t(p[1]) << 16) |
           (uint32_t(p[2]) << 8) | uint32_t(p[3]);
}

inline int16_t LoadS16(const uint8_t* p) {
    return static_cast<int16_t>(LoadU16(p));
}

inline int32_t LoadS32(const uint8_t* p) {
    return static_cast<int32_t>(LoadU32(p));
}

inline void StoreU16(uint16_t v, uint8_t* p) {
    p[0] = static_cast<uint8_t>((v >> 8) & 0xFF);
    p[1] = static_cast<uint8_t>(v & 0xFF);
}

inline void StoreU32(uint32_t v, uint8_t* p) {
    p[0] = static_cast<uint8_t>((v >> 24) & 0xFF);
    p[1] = static_cast<uint8_t>((v >> 16) & 0xFF);
    p[2] = static_cast<uint8_t>((v >> 8) & 0xFF);
    p[3] = static_cast<uint8_t>(v & 0xFF);
}

inline void StoreS16(int16_t v, uint8_t* p) {
    StoreU16(static_cast<uint16_t>(v), p);
}

inline void StoreS32(int32_t v, uint8_t* p) {
    StoreU32(static_cast<uint32_t>(v), p);
}

inline int32_t QuantizeFloat(float value, float scale) {
    const double scaled = static_cast<double>(value) * static_cast<double>(scale);
    const double clamped = std::clamp(scaled,
        static_cast<double>(std::numeric_limits<int32_t>::min()),
        static_cast<double>(std::numeric_limits<int32_t>::max()));
    return static_cast<int32_t>(std::llround(clamped));
}

inline float DequantizeFloat(int32_t fixed, float scale) {
    return static_cast<float>(static_cast<double>(fixed) / static_cast<double>(scale));
}

} // namespace detail

// ============================================================================
// Message Structs
// ============================================================================

/// Test command for unit tests
struct TestCmd {
    static constexpr MessageTypeId kTypeId = MessageTypeId::TestCmd;
    static constexpr std::size_t kWireSize = kTestCmdSize;

    float value1{0}; // First test value
    float value2{0}; // Second test value
    uint16_t durationMs{0}; // Command duration in milliseconds (ms)

    bool Encode(uint8_t* out, std::size_t capacity) const {
        if (capacity < kWireSize) return false;
        if (!std::isfinite(value1)) return false;
        detail::StoreS32(detail::QuantizeFloat(value1, 10000.0f), &out[0]);
        if (!std::isfinite(value2)) return false;
        detail::StoreS32(detail::QuantizeFloat(value2, 10000.0f), &out[4]);
        detail::StoreU16(durationMs, &out[8]);
        return true;
    }

    static std::optional<TestCmd> Decode(const uint8_t* data, std::size_t length) {
        if (length < kWireSize) return std::nullopt;
        TestCmd msg;
        msg.value1 = detail::DequantizeFloat(detail::LoadS32(&data[0]), 10000.0f);
        if (!std::isfinite(msg.value1)) return std::nullopt;
        msg.value2 = detail::DequantizeFloat(detail::LoadS32(&data[4]), 10000.0f);
        if (!std::isfinite(msg.value2)) return std::nullopt;
        msg.durationMs = detail::LoadU16(&data[8]);
        return msg;
    }
};

/// Drivetrain telemetry - absolute state snapshot
struct DrivetrainState {
    static constexpr MessageTypeId kTypeId = MessageTypeId::DrivetrainState;
    static constexpr std::size_t kWireSize = kDrivetrainStateSize;

    float vxActual{0}; // Actual linear velocity (m/s)
    float omegaActual{0}; // Actual angular velocity (rad/s)
    int32_t leftPos{0}; // Left encoder position (absolute) (ticks)
    int32_t rightPos{0}; // Right encoder position (absolute) (ticks)
    uint32_t timestampMs{0}; // Robot timestamp (FPGA time) (ms)

    bool Encode(uint8_t* out, std::size_t capacity) const {
        if (capacity < kWireSize) return false;
        if (!std::isfinite(vxActual)) return false;
        detail::StoreS32(detail::QuantizeFloat(vxActual, 10000.0f), &out[0]);
        if (!std::isfinite(omegaActual)) return false;
        detail::StoreS32(detail::QuantizeFloat(omegaActual, 10000.0f), &out[4]);
        detail::StoreS32(leftPos, &out[8]);
        detail::StoreS32(rightPos, &out[12]);
        detail::StoreU32(timestampMs, &out[16]);
        return true;
    }

    static std::optional<DrivetrainState> Decode(const uint8_t* data, std::size_t length) {
        if (length < kWireSize) return std::nullopt;
        DrivetrainState msg;
        msg.vxActual = detail::DequantizeFloat(detail::LoadS32(&data[0]), 10000.0f);
        if (!std::isfinite(msg.vxActual)) return std::nullopt;
        msg.omegaActual = detail::DequantizeFloat(detail::LoadS32(&data[4]), 10000.0f);
        if (!std::isfinite(msg.omegaActual)) return std::nullopt;
        msg.leftPos = detail::LoadS32(&data[8]);
        msg.rightPos = detail::LoadS32(&data[12]);
        msg.timestampMs = detail::LoadU32(&data[16]);
        return msg;
    }
};

/// Generic encoder telemetry - batch multiple in one packet
struct EncoderData {
    static constexpr MessageTypeId kTypeId = MessageTypeId::EncoderData;
    static constexpr std::size_t kWireSize = kEncoderDataSize;

    uint8_t moduleId{0}; // Module/motor identifier (0-255)
    int32_t position{0}; // Absolute encoder position (ticks)
    int32_t velocity{0}; // Encoder velocity (ticks/100ms)

    bool Encode(uint8_t* out, std::size_t capacity) const {
        if (capacity < kWireSize) return false;
        out[0] = static_cast<uint8_t>(moduleId);
        detail::StoreS32(position, &out[1]);
        detail::StoreS32(velocity, &out[5]);
        return true;
    }

    static std::optional<EncoderData> Decode(const uint8_t* data, std::size_t length) {
        if (length < kWireSize) return std::nullopt;
        EncoderData msg;
        msg.moduleId = data[0];
        msg.position = detail::LoadS32(&data[1]);
        msg.velocity = detail::LoadS32(&data[5]);
        return msg;
    }
};

/// Proximity sensor telemetry
struct ProximityAlert {
    static constexpr MessageTypeId kTypeId = MessageTypeId::ProximityAlert;
    static constexpr std::size_t kWireSize = kProximityAlertSize;

    uint8_t sensorId{0}; // Sensor identifier
    uint16_t distanceMm{0}; // Distance reading in millimeters (mm)
    uint8_t triggered{0}; // Boolean: 1 if below threshold, 0 otherwise

    bool Encode(uint8_t* out, std::size_t capacity) const {
        if (capacity < kWireSize) return false;
        out[0] = static_cast<uint8_t>(sensorId);
        detail::StoreU16(distanceMm, &out[1]);
        out[3] = static_cast<uint8_t>(triggered);
        return true;
    }

    static std::optional<ProximityAlert> Decode(const uint8_t* data, std::size_t length) {
        if (length < kWireSize) return std::nullopt;
        ProximityAlert msg;
        msg.sensorId = data[0];
        msg.distanceMm = detail::LoadU16(&data[1]);
        msg.triggered = data[3];
        return msg;
    }
};

// ============================================================================
// Message Variant (for type-erased handling)
// ============================================================================

using Message = std::variant<TestCmd, DrivetrainState, EncoderData, ProximityAlert>;

// ============================================================================
// Message Registry
// ============================================================================

struct MessageInfo {
    MessageTypeId typeId;
    std::size_t wireSize;
    const char* name;
};

inline constexpr std::array<MessageInfo, 4> kMessageRegistry = {{
    {MessageTypeId::TestCmd, 10, "TestCmd"},
    {MessageTypeId::DrivetrainState, 20, "DrivetrainState"},
    {MessageTypeId::EncoderData, 9, "EncoderData"},
    {MessageTypeId::ProximityAlert, 4, "ProximityAlert"},
}};

inline std::optional<MessageInfo> GetMessageInfo(MessageTypeId typeId) {
    for (const auto& info : kMessageRegistry) {
        if (info.typeId == typeId) return info;
    }
    return std::nullopt;
}

inline std::optional<MessageInfo> GetMessageInfo(uint16_t typeId) {
    return GetMessageInfo(static_cast<MessageTypeId>(typeId));
}

// ============================================================================
// Handshake Utilities
// ============================================================================

/// Encode handshake with default schema hash
inline bool EncodeHandshake(uint8_t* out, std::size_t capacity) {
    if (capacity < kHandshakeSize) return false;
    std::memcpy(out, kHandshakeMagic.data(), 4);
    detail::StoreU32(kSchemaHash, &out[4]);
    return true;
}

/// Encode handshake with custom schema hash (for testing)
inline bool EncodeHandshakeWithHash(uint8_t* out, std::size_t capacity, uint32_t schemaHash) {
    if (capacity < kHandshakeSize) return false;
    std::memcpy(out, kHandshakeMagic.data(), 4);
    detail::StoreU32(schemaHash, &out[4]);
    return true;
}

inline bool ValidateHandshake(const uint8_t* data, std::size_t length) {
    if (length < kHandshakeSize) return false;
    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;
    const uint32_t remoteHash = detail::LoadU32(&data[4]);
    return remoteHash == kSchemaHash;
}

/// Validate handshake against custom expected hash (for testing)
inline bool ValidateHandshakeWithHash(const uint8_t* data, std::size_t length, uint32_t expectedHash) {
    if (length < kHandshakeSize) return false;
    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;
    const uint32_t remoteHash = detail::LoadU32(&data[4]);
    return remoteHash == expectedHash;
}

inline uint32_t ExtractSchemaHash(const uint8_t* data, std::size_t length) {
    if (length < kHandshakeSize) return 0;
    return detail::LoadU32(&data[4]);
}

} // namespace bcnp
