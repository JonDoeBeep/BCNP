"""
AUTO-GENERATED by bcnp_codegen.py - DO NOT EDIT
Schema version: 3.2
Schema hash: 0x0152BCDB
"""

import struct
from dataclasses import dataclass
from typing import Optional, Union

PROTOCOL_MAJOR = 3
PROTOCOL_MINOR = 2
SCHEMA_HASH = 0x0152BCDB
HANDSHAKE_MAGIC = b'BCNP'
HEADER_SIZE_V3 = 7

def crc32(data: bytes) -> int:
    """IEEE CRC32 matching BCNP implementation."""
    crc = 0xFFFFFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ 0xEDB88320
            else:
                crc >>= 1
    return crc ^ 0xFFFFFFFF

class MessageTypeId:
    Unknown = 0
    DriveCmd = 1

@dataclass
class DriveCmd:
    """
    Differential drive velocity command
    Wire size: 10 bytes
    """
    TYPE_ID = MessageTypeId.DriveCmd
    WIRE_SIZE = 10

    vx: float = 0
    omega: float = 0
    durationMs: int = 0

    def encode(self) -> bytes:
        """Encode message to wire format (big-endian)."""
        return struct.pack(">iiH", int(round(self.vx * 10000)), int(round(self.omega * 10000)), self.durationMs)

    @classmethod
    def decode(cls, data: bytes) -> Optional['DriveCmd']:
        """Decode message from wire format."""
        if len(data) < cls.WIRE_SIZE:
            return None
        values = struct.unpack(">iiH", data[:cls.WIRE_SIZE])
        return cls(vx=values[0] / 10000, omega=values[1] / 10000, durationMs=values[2])

Message = Union[DriveCmd]

MESSAGE_REGISTRY = {
    MessageTypeId.DriveCmd: DriveCmd,
}

def encode_handshake() -> bytes:
    """Create handshake packet with schema hash."""
    return HANDSHAKE_MAGIC + struct.pack('>I', SCHEMA_HASH)

def validate_handshake(data: bytes) -> bool:
    """Validate incoming handshake matches our schema."""
    if len(data) < 8:
        return False
    if data[:4] != HANDSHAKE_MAGIC:
        return False
    remote_hash = struct.unpack('>I', data[4:8])[0]
    return remote_hash == SCHEMA_HASH

def encode_packet(msg_type_id: int, messages: list, flags: int = 0) -> bytes:
    """Encode a complete BCNP v3 packet with header and CRC."""
    # Header: major(1) + minor(1) + flags(1) + msgTypeId(2) + msgCount(2)
    header = struct.pack('>BBBHH', PROTOCOL_MAJOR, PROTOCOL_MINOR, flags, msg_type_id, len(messages))
    payload = b''.join(m.encode() for m in messages)
    packet_data = header + payload
    checksum = struct.pack('>I', crc32(packet_data))
    return packet_data + checksum
