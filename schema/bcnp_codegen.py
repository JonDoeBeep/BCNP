#!/usr/bin/env python3
"""
BCNP Schema Compiler

Compiles BCNP message schema (JSON) to C++ header and Python bindings.
Generates serialization/deserialization code and computes schema hash (CRC32).

Usage:
    python bcnp_codegen.py schema/messages.json --cpp src/bcnp/generated/
    python bcnp_codegen.py schema/messages.json --python examples/
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Any

# Type info: (wire_size, cpp_type, is_signed, python_struct_fmt)
TYPE_INFO = {
    "int8":    (1, "int8_t",   True,  "b"),
    "uint8":   (1, "uint8_t",  False, "B"),
    "int16":   (2, "int16_t",  True,  "h"),
    "uint16":  (2, "uint16_t", False, "H"),
    "int32":   (4, "int32_t",  True,  "i"),
    "uint32":  (4, "uint32_t", False, "I"),
    "float32": (4, "float",    True,  "f"),  # Encoded as int32 with scale
}


def compute_crc32(data: bytes) -> int:
    """IEEE CRC32 matching BCNP's existing implementation."""
    crc = 0xFFFFFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ 0xEDB88320
            else:
                crc >>= 1
    return crc ^ 0xFFFFFFFF


def canonical_json(schema: dict) -> str:
    """
    Produce a canonical JSON string for schema hashing.
    Only includes structurally significant fields (id, name, type, scale).
    """
    canonical = {
        "version": schema["version"],
        "messages": []
    }
    for msg in sorted(schema["messages"], key=lambda m: m["id"]):
        msg_canonical = {
            "id": msg["id"],
            "name": msg["name"],
            "fields": []
        }
        for field in msg["fields"]:
            field_canonical = {
                "name": field["name"],
                "type": field["type"]
            }
            if "scale" in field:
                field_canonical["scale"] = field["scale"]
            msg_canonical["fields"].append(field_canonical)
        canonical["messages"].append(msg_canonical)
    return json.dumps(canonical, separators=(",", ":"), sort_keys=True)


def compute_schema_hash(schema: dict) -> int:
    """Compute CRC32 of canonical JSON schema."""
    canonical = canonical_json(schema)
    return compute_crc32(canonical.encode("utf-8"))


def compute_message_size(msg: dict) -> int:
    """Compute wire size of a message in bytes."""
    size = 0
    for field in msg["fields"]:
        size += TYPE_INFO[field["type"]][0]
    return size


def generate_cpp_header(schema: dict, output_dir: Path) -> None:
    """Generate C++ header with message types and serialization.
    
    The file is written to output_dir/bcnp/message_types.h so that
    users can add output_dir to their include path and use:
        #include <bcnp/message_types.h>
    """
    bcnp_dir = output_dir / "bcnp"
    bcnp_dir.mkdir(parents=True, exist_ok=True)
    output_file = bcnp_dir / "message_types.h"
    
    namespace = schema.get("namespace", "bcnp")
    version_parts = schema["version"].split(".")
    major = int(version_parts[0])
    minor = int(version_parts[1])
    schema_hash = compute_schema_hash(schema)
    
    lines = []
    lines.append("// AUTO-GENERATED by bcnp_codegen.py - DO NOT EDIT")
    lines.append(f"// Schema version: {schema['version']}")
    lines.append(f"// Schema hash: 0x{schema_hash:08X}")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <array>")
    lines.append("#include <cstddef>")
    lines.append("#include <cstdint>")
    lines.append("#include <cmath>")
    lines.append("#include <cstring>")
    lines.append("#include <functional>")
    lines.append("#include <limits>")
    lines.append("#include <optional>")
    lines.append("#include <variant>")
    lines.append("")
    lines.append(f"namespace {namespace} {{")
    lines.append("")
    lines.append("// ============================================================================")
    lines.append("// Protocol Constants")
    lines.append("// ============================================================================")
    lines.append("")
    lines.append(f"constexpr uint8_t kProtocolMajorV3 = {major};")
    lines.append(f"constexpr uint8_t kProtocolMinorV3 = {minor};")
    lines.append(f"constexpr uint32_t kSchemaHash = 0x{schema_hash:08X}U;")
    lines.append("")
    lines.append("// Handshake packet structure: \"BCNP\" (4 bytes) + schema hash (4 bytes)")
    lines.append("constexpr std::size_t kHandshakeSize = 8;")
    lines.append("constexpr std::array<uint8_t, 4> kHandshakeMagic = {{'B', 'C', 'N', 'P'}};")
    lines.append("")
    lines.append("// V3 Header: Major(1) + Minor(1) + Flags(1) + MsgTypeId(2) + MsgCount(2) = 7 bytes")
    lines.append("constexpr std::size_t kHeaderSizeV3 = 7;")
    lines.append("constexpr std::size_t kHeaderMsgTypeIndex = 3;")
    lines.append("constexpr std::size_t kHeaderMsgCountIndex = 5;")
    lines.append("")
    
    # Message type IDs enum
    lines.append("// ============================================================================")
    lines.append("// Message Type IDs")
    lines.append("// ============================================================================")
    lines.append("")
    lines.append("enum class MessageTypeId : uint16_t {")
    lines.append("    Unknown = 0,")
    for msg in schema["messages"]:
        lines.append(f"    {msg['name']} = {msg['id']},")
    lines.append("};")
    lines.append("")
    
    # Message size constants
    lines.append("// Message sizes (wire format, bytes)")
    for msg in schema["messages"]:
        size = compute_message_size(msg)
        lines.append(f"constexpr std::size_t k{msg['name']}Size = {size};")
    lines.append("")
    
    # Byte order utilities
    lines.append("// ============================================================================")
    lines.append("// Byte Order Utilities (Big-Endian Wire Format)")
    lines.append("// ============================================================================")
    lines.append("")
    lines.append("namespace detail {")
    lines.append("")
    lines.append("inline uint16_t LoadU16(const uint8_t* p) {")
    lines.append("    return (uint16_t(p[0]) << 8) | uint16_t(p[1]);")
    lines.append("}")
    lines.append("")
    lines.append("inline uint32_t LoadU32(const uint8_t* p) {")
    lines.append("    return (uint32_t(p[0]) << 24) | (uint32_t(p[1]) << 16) |")
    lines.append("           (uint32_t(p[2]) << 8) | uint32_t(p[3]);")
    lines.append("}")
    lines.append("")
    lines.append("inline int16_t LoadS16(const uint8_t* p) {")
    lines.append("    return static_cast<int16_t>(LoadU16(p));")
    lines.append("}")
    lines.append("")
    lines.append("inline int32_t LoadS32(const uint8_t* p) {")
    lines.append("    return static_cast<int32_t>(LoadU32(p));")
    lines.append("}")
    lines.append("")
    lines.append("inline void StoreU16(uint16_t v, uint8_t* p) {")
    lines.append("    p[0] = static_cast<uint8_t>((v >> 8) & 0xFF);")
    lines.append("    p[1] = static_cast<uint8_t>(v & 0xFF);")
    lines.append("}")
    lines.append("")
    lines.append("inline void StoreU32(uint32_t v, uint8_t* p) {")
    lines.append("    p[0] = static_cast<uint8_t>((v >> 24) & 0xFF);")
    lines.append("    p[1] = static_cast<uint8_t>((v >> 16) & 0xFF);")
    lines.append("    p[2] = static_cast<uint8_t>((v >> 8) & 0xFF);")
    lines.append("    p[3] = static_cast<uint8_t>(v & 0xFF);")
    lines.append("}")
    lines.append("")
    lines.append("inline void StoreS16(int16_t v, uint8_t* p) {")
    lines.append("    StoreU16(static_cast<uint16_t>(v), p);")
    lines.append("}")
    lines.append("")
    lines.append("inline void StoreS32(int32_t v, uint8_t* p) {")
    lines.append("    StoreU32(static_cast<uint32_t>(v), p);")
    lines.append("}")
    lines.append("")
    lines.append("inline int32_t QuantizeFloat(float value, float scale) {")
    lines.append("    const double scaled = static_cast<double>(value) * static_cast<double>(scale);")
    lines.append("    const double clamped = std::clamp(scaled,")
    lines.append("        static_cast<double>(std::numeric_limits<int32_t>::min()),")
    lines.append("        static_cast<double>(std::numeric_limits<int32_t>::max()));")
    lines.append("    return static_cast<int32_t>(std::llround(clamped));")
    lines.append("}")
    lines.append("")
    lines.append("inline float DequantizeFloat(int32_t fixed, float scale) {")
    lines.append("    return static_cast<float>(static_cast<double>(fixed) / static_cast<double>(scale));")
    lines.append("}")
    lines.append("")
    lines.append("} // namespace detail")
    lines.append("")
    
    # Generate message structs
    lines.append("// ============================================================================")
    lines.append("// Message Structs")
    lines.append("// ============================================================================")
    lines.append("")
    
    for msg in schema["messages"]:
        desc = msg.get("description", "")
        lines.append(f"/// {desc}")
        lines.append(f"struct {msg['name']} {{")
        lines.append(f"    static constexpr MessageTypeId kTypeId = MessageTypeId::{msg['name']};")
        lines.append(f"    static constexpr std::size_t kWireSize = k{msg['name']}Size;")
        lines.append("")
        for field in msg["fields"]:
            cpp_type = TYPE_INFO[field["type"]][1]
            if field["type"] == "float32":
                cpp_type = "float"  # User sees float, wire is int32
            field_desc = field.get("description", "")
            unit = field.get("unit", "")
            comment = f" // {field_desc}" if field_desc else ""
            if unit:
                comment = f" // {field_desc} ({unit})" if field_desc else f" // ({unit})"
            lines.append(f"    {cpp_type} {field['name']}{{0}};{comment}")
        lines.append("")
        
        # Encode method
        lines.append("    bool Encode(uint8_t* out, std::size_t capacity) const {")
        lines.append(f"        if (capacity < kWireSize) return false;")
        offset = 0
        for field in msg["fields"]:
            ftype = field["type"]
            fname = field["name"]
            size = TYPE_INFO[ftype][0]
            
            if ftype == "float32":
                scale = field.get("scale", 10000)
                lines.append(f"        if (!std::isfinite({fname})) return false;")
                lines.append(f"        detail::StoreS32(detail::QuantizeFloat({fname}, {scale}.0f), &out[{offset}]);")
            elif ftype == "int32":
                lines.append(f"        detail::StoreS32({fname}, &out[{offset}]);")
            elif ftype == "uint32":
                lines.append(f"        detail::StoreU32({fname}, &out[{offset}]);")
            elif ftype == "int16":
                lines.append(f"        detail::StoreS16({fname}, &out[{offset}]);")
            elif ftype == "uint16":
                lines.append(f"        detail::StoreU16({fname}, &out[{offset}]);")
            elif ftype in ("int8", "uint8"):
                lines.append(f"        out[{offset}] = static_cast<uint8_t>({fname});")
            offset += size
        lines.append("        return true;")
        lines.append("    }")
        lines.append("")
        
        # Decode method
        lines.append(f"    static std::optional<{msg['name']}> Decode(const uint8_t* data, std::size_t length) {{")
        lines.append(f"        if (length < kWireSize) return std::nullopt;")
        lines.append(f"        {msg['name']} msg;")
        offset = 0
        for field in msg["fields"]:
            ftype = field["type"]
            fname = field["name"]
            size = TYPE_INFO[ftype][0]
            
            if ftype == "float32":
                scale = field.get("scale", 10000)
                lines.append(f"        msg.{fname} = detail::DequantizeFloat(detail::LoadS32(&data[{offset}]), {scale}.0f);")
                lines.append(f"        if (!std::isfinite(msg.{fname})) return std::nullopt;")
            elif ftype == "int32":
                lines.append(f"        msg.{fname} = detail::LoadS32(&data[{offset}]);")
            elif ftype == "uint32":
                lines.append(f"        msg.{fname} = detail::LoadU32(&data[{offset}]);")
            elif ftype == "int16":
                lines.append(f"        msg.{fname} = detail::LoadS16(&data[{offset}]);")
            elif ftype == "uint16":
                lines.append(f"        msg.{fname} = detail::LoadU16(&data[{offset}]);")
            elif ftype == "uint8":
                lines.append(f"        msg.{fname} = data[{offset}];")
            elif ftype == "int8":
                lines.append(f"        msg.{fname} = static_cast<int8_t>(data[{offset}]);")
            offset += size
        lines.append("        return msg;")
        lines.append("    }")
        lines.append("};")
        lines.append("")
    
    # Message variant type (only if messages exist)
    if schema["messages"]:
        lines.append("// ============================================================================")
        lines.append("// Message Variant (for type-erased handling)")
        lines.append("// ============================================================================")
        lines.append("")
        variant_types = ", ".join(msg["name"] for msg in schema["messages"])
        lines.append(f"using Message = std::variant<{variant_types}>;")
        lines.append("")
    
    # Message registry
    lines.append("// ============================================================================")
    lines.append("// Message Registry")
    lines.append("// ============================================================================")
    lines.append("")
    lines.append("struct MessageInfo {")
    lines.append("    MessageTypeId typeId;")
    lines.append("    std::size_t wireSize;")
    lines.append("    const char* name;")
    lines.append("};")
    lines.append("")
    num_messages = len(schema["messages"])
    if num_messages > 0:
        lines.append(f"inline constexpr std::array<MessageInfo, {num_messages}> kMessageRegistry = {{{{")
        for msg in schema["messages"]:
            size = compute_message_size(msg)
            lines.append(f"    {{MessageTypeId::{msg['name']}, {size}, \"{msg['name']}\"}},")
        lines.append("}};")
    else:
        lines.append("// No messages defined - add message types to your schema and regenerate")
        lines.append("inline constexpr std::array<MessageInfo, 0> kMessageRegistry = {{}};")
    lines.append("")
    lines.append("inline std::optional<MessageInfo> GetMessageInfo(MessageTypeId typeId) {")
    lines.append("    for (const auto& info : kMessageRegistry) {")
    lines.append("        if (info.typeId == typeId) return info;")
    lines.append("    }")
    lines.append("    return std::nullopt;")
    lines.append("}")
    lines.append("")
    lines.append("inline std::optional<MessageInfo> GetMessageInfo(uint16_t typeId) {")
    lines.append("    return GetMessageInfo(static_cast<MessageTypeId>(typeId));")
    lines.append("}")
    lines.append("")
    
    # Handshake utilities
    lines.append("// ============================================================================")
    lines.append("// Handshake Utilities")
    lines.append("// ============================================================================")
    lines.append("")
    lines.append("/// Encode handshake with default schema hash")
    lines.append("inline bool EncodeHandshake(uint8_t* out, std::size_t capacity) {")
    lines.append("    if (capacity < kHandshakeSize) return false;")
    lines.append("    std::memcpy(out, kHandshakeMagic.data(), 4);")
    lines.append("    detail::StoreU32(kSchemaHash, &out[4]);")
    lines.append("    return true;")
    lines.append("}")
    lines.append("")
    lines.append("/// Encode handshake with custom schema hash (for testing)")
    lines.append("inline bool EncodeHandshakeWithHash(uint8_t* out, std::size_t capacity, uint32_t schemaHash) {")
    lines.append("    if (capacity < kHandshakeSize) return false;")
    lines.append("    std::memcpy(out, kHandshakeMagic.data(), 4);")
    lines.append("    detail::StoreU32(schemaHash, &out[4]);")
    lines.append("    return true;")
    lines.append("}")
    lines.append("")
    lines.append("inline bool ValidateHandshake(const uint8_t* data, std::size_t length) {")
    lines.append("    if (length < kHandshakeSize) return false;")
    lines.append("    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;")
    lines.append("    const uint32_t remoteHash = detail::LoadU32(&data[4]);")
    lines.append("    return remoteHash == kSchemaHash;")
    lines.append("}")
    lines.append("")
    lines.append("/// Validate handshake against custom expected hash (for testing)")
    lines.append("inline bool ValidateHandshakeWithHash(const uint8_t* data, std::size_t length, uint32_t expectedHash) {")
    lines.append("    if (length < kHandshakeSize) return false;")
    lines.append("    if (std::memcmp(data, kHandshakeMagic.data(), 4) != 0) return false;")
    lines.append("    const uint32_t remoteHash = detail::LoadU32(&data[4]);")
    lines.append("    return remoteHash == expectedHash;")
    lines.append("}")
    lines.append("")
    lines.append("inline uint32_t ExtractSchemaHash(const uint8_t* data, std::size_t length) {")
    lines.append("    if (length < kHandshakeSize) return 0;")
    lines.append("    return detail::LoadU32(&data[4]);")
    lines.append("}")
    lines.append("")
    
    lines.append(f"}} // namespace {namespace}")
    lines.append("")
    
    output_file.write_text("\n".join(lines))
    print(f"Generated: {output_file}")


def generate_python_bindings(schema: dict, output_dir: Path) -> None:
    """Generate Python module with message classes and serialization."""
    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / "bcnp_messages.py"
    
    schema_hash = compute_schema_hash(schema)
    
    lines = []
    lines.append('"""')
    lines.append("AUTO-GENERATED by bcnp_codegen.py - DO NOT EDIT")
    lines.append(f"Schema version: {schema['version']}")
    lines.append(f"Schema hash: 0x{schema_hash:08X}")
    lines.append('"""')
    lines.append("")
    lines.append("import struct")
    lines.append("from dataclasses import dataclass")
    lines.append("from typing import Optional, Union")
    lines.append("")
    lines.append(f"PROTOCOL_MAJOR = {schema['version'].split('.')[0]}")
    lines.append(f"PROTOCOL_MINOR = {schema['version'].split('.')[1]}")
    lines.append(f"SCHEMA_HASH = 0x{schema_hash:08X}")
    lines.append("HANDSHAKE_MAGIC = b'BCNP'")
    lines.append("HEADER_SIZE_V3 = 7")
    lines.append("")
    
    # CRC32 function
    lines.append("def crc32(data: bytes) -> int:")
    lines.append('    """IEEE CRC32 matching BCNP implementation."""')
    lines.append("    crc = 0xFFFFFFFF")
    lines.append("    for byte in data:")
    lines.append("        crc ^= byte")
    lines.append("        for _ in range(8):")
    lines.append("            if crc & 1:")
    lines.append("                crc = (crc >> 1) ^ 0xEDB88320")
    lines.append("            else:")
    lines.append("                crc >>= 1")
    lines.append("    return crc ^ 0xFFFFFFFF")
    lines.append("")
    
    # Message type enum
    lines.append("class MessageTypeId:")
    lines.append("    Unknown = 0")
    for msg in schema["messages"]:
        lines.append(f"    {msg['name']} = {msg['id']}")
    lines.append("")
    
    # Generate message classes
    for msg in schema["messages"]:
        size = compute_message_size(msg)
        lines.append("@dataclass")
        lines.append(f"class {msg['name']}:")
        lines.append(f'    """')
        lines.append(f"    {msg.get('description', msg['name'])}")
        lines.append(f"    Wire size: {size} bytes")
        lines.append(f'    """')
        lines.append(f"    TYPE_ID = MessageTypeId.{msg['name']}")
        lines.append(f"    WIRE_SIZE = {size}")
        lines.append("")
        for field in msg["fields"]:
            py_type = "float" if field["type"] == "float32" else "int"
            lines.append(f"    {field['name']}: {py_type} = 0")
        lines.append("")
        
        # Encode method
        lines.append("    def encode(self) -> bytes:")
        lines.append('        """Encode message to wire format (big-endian)."""')
        encode_parts = []
        for field in msg["fields"]:
            ftype = field["type"]
            fname = field["name"]
            if ftype == "float32":
                scale = field.get("scale", 10000)
                encode_parts.append(f"int(round(self.{fname} * {scale}))")
            else:
                encode_parts.append(f"self.{fname}")
        
        # Build struct format string
        fmt_parts = []
        for field in msg["fields"]:
            ftype = field["type"]
            if ftype == "float32":
                fmt_parts.append("i")  # Encoded as int32
            elif ftype in ("int32", "uint32"):
                fmt_parts.append("i" if ftype == "int32" else "I")
            elif ftype in ("int16", "uint16"):
                fmt_parts.append("h" if ftype == "int16" else "H")
            else:
                fmt_parts.append("b" if ftype == "int8" else "B")
        
        fmt_str = ">" + "".join(fmt_parts)
        encode_args = ", ".join(encode_parts)
        lines.append(f'        return struct.pack("{fmt_str}", {encode_args})')
        lines.append("")
        
        # Decode method
        lines.append("    @classmethod")
        lines.append(f"    def decode(cls, data: bytes) -> Optional['{msg['name']}']:")
        lines.append('        """Decode message from wire format."""')
        lines.append(f"        if len(data) < cls.WIRE_SIZE:")
        lines.append("            return None")
        lines.append(f'        values = struct.unpack("{fmt_str}", data[:cls.WIRE_SIZE])')
        
        decode_parts = []
        for i, field in enumerate(msg["fields"]):
            ftype = field["type"]
            fname = field["name"]
            if ftype == "float32":
                scale = field.get("scale", 10000)
                decode_parts.append(f"{fname}=values[{i}] / {scale}")
            else:
                decode_parts.append(f"{fname}=values[{i}]")
        
        decode_args = ", ".join(decode_parts)
        lines.append(f"        return cls({decode_args})")
        lines.append("")
    
    # Message union type (only if messages exist)
    if schema["messages"]:
        lines.append(f"Message = Union[{', '.join(msg['name'] for msg in schema['messages'])}]")
        lines.append("")
        
        # Registry
        lines.append("MESSAGE_REGISTRY = {")
        for msg in schema["messages"]:
            lines.append(f"    MessageTypeId.{msg['name']}: {msg['name']},")
        lines.append("}")
    else:
        lines.append("# No messages defined - add message types to your schema and regenerate")
        lines.append("MESSAGE_REGISTRY = {}")
    lines.append("")
    
    # Handshake functions
    lines.append("def encode_handshake() -> bytes:")
    lines.append('    """Create handshake packet with schema hash."""')
    lines.append("    return HANDSHAKE_MAGIC + struct.pack('>I', SCHEMA_HASH)")
    lines.append("")
    lines.append("def validate_handshake(data: bytes) -> bool:")
    lines.append('    """Validate incoming handshake matches our schema."""')
    lines.append("    if len(data) < 8:")
    lines.append("        return False")
    lines.append("    if data[:4] != HANDSHAKE_MAGIC:")
    lines.append("        return False")
    lines.append("    remote_hash = struct.unpack('>I', data[4:8])[0]")
    lines.append("    return remote_hash == SCHEMA_HASH")
    lines.append("")
    
    # Packet encoder
    lines.append("def encode_packet(msg_type_id: int, messages: list, flags: int = 0) -> bytes:")
    lines.append('    """Encode a complete BCNP v3 packet with header and CRC."""')
    lines.append("    # Header: major(1) + minor(1) + flags(1) + msgTypeId(2) + msgCount(2)")
    lines.append("    header = struct.pack('>BBBHH', PROTOCOL_MAJOR, PROTOCOL_MINOR, flags, msg_type_id, len(messages))")
    lines.append("    payload = b''.join(m.encode() for m in messages)")
    lines.append("    packet_data = header + payload")
    lines.append("    checksum = struct.pack('>I', crc32(packet_data))")
    lines.append("    return packet_data + checksum")
    lines.append("")
    
    output_file.write_text("\n".join(lines))
    print(f"Generated: {output_file}")


def main():
    parser = argparse.ArgumentParser(description="BCNP Schema Compiler")
    parser.add_argument("schema", type=Path, help="Path to messages.json")
    parser.add_argument("--cpp", type=Path, help="Output directory for C++ header")
    parser.add_argument("--python", type=Path, help="Output directory for Python bindings")
    args = parser.parse_args()
    
    if not args.schema.exists():
        print(f"Error: Schema file not found: {args.schema}", file=sys.stderr)
        sys.exit(1)
    
    with open(args.schema) as f:
        schema = json.load(f)
    
    # Validate basic structure
    if "version" not in schema or "messages" not in schema:
        print("Error: Schema must have 'version' and 'messages' fields", file=sys.stderr)
        sys.exit(1)
    
    schema_hash = compute_schema_hash(schema)
    print(f"Schema version: {schema['version']}")
    print(f"Schema hash: 0x{schema_hash:08X}")
    print(f"Messages: {len(schema['messages'])}")
    
    if args.cpp:
        generate_cpp_header(schema, args.cpp)
    
    if args.python:
        generate_python_bindings(schema, args.python)
    
    if not args.cpp and not args.python:
        print("\nNo output specified. Use --cpp and/or --python to generate code.")
        print(f"\nCanonical JSON for hashing:\n{canonical_json(schema)}")


if __name__ == "__main__":
    main()
